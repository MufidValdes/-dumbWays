"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var query_exports = {};
__export(query_exports, {
  PostgresQuery: () => PostgresQuery
});
module.exports = __toCommonJS(query_exports);
var import_core = require("@sequelize/core");
var import_logger = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js");
var import_escapeRegExp = __toESM(require("lodash/escapeRegExp"));
var import_forOwn = __toESM(require("lodash/forOwn"));
var import_isEmpty = __toESM(require("lodash/isEmpty"));
var import_isEqual = __toESM(require("lodash/isEqual"));
var import_mapKeys = __toESM(require("lodash/mapKeys"));
var import_toPairs = __toESM(require("lodash/toPairs"));
var import_zipObject = __toESM(require("lodash/zipObject"));
const debug = import_logger.logger.debugContext("sql:pg");
class PostgresQuery extends import_core.AbstractQuery {
  async run(sql, parameters, options) {
    const { connection } = this;
    if (!(0, import_isEmpty.default)(this.options.searchPath)) {
      sql = this.sequelize.queryGenerator.setSearchPath(this.options.searchPath) + sql;
    }
    if (options?.minifyAliases && this.options.includeAliases) {
      for (const [alias, original] of (0, import_toPairs.default)(this.options.includeAliases).sort((a, b) => b[1].length - a[1].length)) {
        const reg = new RegExp((0, import_escapeRegExp.default)(original), "g");
        sql = sql.replace(reg, alias);
      }
    }
    this.sql = sql;
    const query = new Promise((resolve, reject) => {
      if (parameters && parameters.length > 0) {
        connection.query(sql, parameters, (error, result) => {
          error ? reject(error) : resolve(result);
        });
      } else {
        connection.query(sql, (error, result) => error ? reject(error) : resolve(result));
      }
    });
    const complete = this._logQuery(sql, debug, parameters);
    let queryResult;
    try {
      queryResult = await query;
    } catch (error) {
      if (error.code === "ECONNRESET" || // https://github.com/sequelize/sequelize/pull/14090
      // pg-native throws custom exception or libpq formatted errors
      /Unable to set non-blocking to true/i.test(error) || /SSL SYSCALL error: EOF detected/i.test(error) || /Local: Authentication failure/i.test(error) || // https://github.com/sequelize/sequelize/pull/15144
      error.message === "Query read timeout") {
        connection._invalid = true;
      }
      error.sql = sql;
      error.parameters = parameters;
      throw this.formatError(error);
    }
    complete();
    let rows = Array.isArray(queryResult) ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), []) : queryResult.rows;
    const rowCount = Array.isArray(queryResult) ? queryResult.reduce(
      (count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count,
      0
    ) : queryResult.rowCount || 0;
    if (options?.minifyAliases && this.options.aliasesMapping) {
      rows = rows.map(
        (row) => (0, import_toPairs.default)(row).reduce((acc, [key, value]) => {
          const mapping = this.options.aliasesMapping.get(key);
          acc[mapping || key] = value;
          return acc;
        }, {})
      );
    }
    const isTableNameQuery = sql.startsWith("SELECT table_name FROM information_schema.tables");
    const isRelNameQuery = sql.startsWith("SELECT relname FROM pg_class WHERE oid IN");
    if (isRelNameQuery) {
      return rows.map((row) => ({
        name: row.relname,
        tableName: row.relname.split("_")[0]
      }));
    }
    if (isTableNameQuery) {
      return rows.map((row) => Object.values(row));
    }
    if (rows[0] && rows[0].sequelize_caught_exception !== void 0) {
      if (rows[0].sequelize_caught_exception !== null) {
        throw this.formatError({
          sql,
          parameters,
          code: "23505",
          detail: rows[0].sequelize_caught_exception
        });
      }
      for (const row of rows) {
        delete row.sequelize_caught_exception;
      }
    }
    if (this.isShowIndexesQuery()) {
      for (const row of rows) {
        let attributes;
        if (/include \(([^]*)\)/gi.test(row.definition)) {
          attributes = /on .*? (?:using .*?\s)?\(([^]*)\) include \(([^]*)\)/gi.exec(row.definition)[1].split(",");
        } else {
          attributes = /on .*? (?:using .*?\s)?\(([^]*)\)/gi.exec(row.definition)[1].split(",");
        }
        const columns = (0, import_zipObject.default)(
          row.column_indexes,
          this.sequelize.queryGenerator.fromArray(row.column_names)
        );
        delete row.column_indexes;
        delete row.column_names;
        let field;
        let attribute;
        row.fields = row.index_fields.map((indKey, index) => {
          field = columns[indKey];
          if (!field) {
            return null;
          }
          attribute = attributes[index];
          return {
            attribute: field,
            collate: /COLLATE "(.*?)"/.test(attribute) ? /COLLATE "(.*?)"/.exec(attribute)[1] : void 0,
            order: attribute.includes("DESC") ? "DESC" : attribute.includes("ASC") ? "ASC" : void 0,
            length: void 0
          };
        }).filter((n) => n !== null);
        row.includes = row.include_fields.map((indKey) => {
          field = columns[indKey];
          if (!field) {
            return null;
          }
          return field;
        }).filter((n) => n !== null);
        delete row.columns;
        delete row.definition;
        delete row.index_fields;
        delete row.include_fields;
      }
      return rows;
    }
    if (this.isSelectQuery()) {
      let result = rows;
      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {
        const attrsMap = /* @__PURE__ */ Object.create(null);
        for (const attrName of this.model.modelDefinition.attributes.keys()) {
          attrsMap[attrName.toLowerCase()] = attrName;
        }
        result = rows.map((row) => {
          return (0, import_mapKeys.default)(row, (value, key) => {
            const targetAttr = attrsMap[key];
            if (typeof targetAttr === "string" && targetAttr !== key) {
              return targetAttr;
            }
            return key;
          });
        });
      }
      return this.handleSelectQuery(result);
    }
    if (import_core.QueryTypes.DESCRIBE === this.options.type) {
      const result = {};
      for (const row of rows) {
        result[row.Field] = {
          type: row.Type.toUpperCase(),
          allowNull: row.Null === "YES",
          defaultValue: row.Default,
          comment: row.Comment,
          special: row.special ? this.sequelize.queryGenerator.fromArray(row.special) : [],
          primaryKey: row.Constraint === "PRIMARY KEY"
        };
        if (result[row.Field].type === "BOOLEAN") {
          result[row.Field].defaultValue = { false: false, true: true }[result[row.Field].defaultValue];
          if (result[row.Field].defaultValue === void 0) {
            result[row.Field].defaultValue = null;
          }
        }
        if (typeof result[row.Field].defaultValue === "string") {
          result[row.Field].defaultValue = result[row.Field].defaultValue.replaceAll("'", "");
          if (result[row.Field].defaultValue.includes("::")) {
            const split = result[row.Field].defaultValue.split("::");
            if (split[1].toLowerCase() !== "regclass)") {
              result[row.Field].defaultValue = split[0];
            }
          }
        }
      }
      return result;
    }
    if (this.isShowOrDescribeQuery()) {
      return rows;
    }
    if (import_core.QueryTypes.BULKUPDATE === this.options.type) {
      if (!this.options.returning) {
        return Number.parseInt(rowCount, 10);
      }
      return this.handleSelectQuery(rows);
    }
    if (this.isDeleteQuery()) {
      return Number.parseInt(rowCount, 10);
    }
    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {
      if (this.instance && this.instance.dataValues) {
        if (this.isInsertQuery() && !this.isUpsertQuery() && rowCount === 0) {
          throw new import_core.EmptyResultError();
        }
        if (rows[0]) {
          for (const attributeOrColumnName of Object.keys(rows[0])) {
            const modelDefinition = this.model.modelDefinition;
            const attribute = modelDefinition.attributes.get(attributeOrColumnName) ?? modelDefinition.columns.get(attributeOrColumnName);
            const updatedValue = this._parseDatabaseValue(
              rows[0][attributeOrColumnName],
              attribute?.type
            );
            this.instance.set(attribute?.fieldName ?? attributeOrColumnName, updatedValue, {
              raw: true,
              comesFromDatabase: true
            });
          }
        }
      }
      if (this.isUpsertQuery()) {
        return [this.instance, null];
      }
      return [
        this.instance || rows && (this.options.plain && rows[0] || rows) || void 0,
        rowCount
      ];
    }
    if (this.isShowConstraintsQuery()) {
      return rows;
    }
    if (this.isRawQuery()) {
      return [rows, queryResult];
    }
    return rows;
  }
  formatError(err) {
    let match;
    let table;
    let index;
    let fields;
    let errors;
    let message;
    const code = err.code || err.sqlState;
    const errMessage = err.message || err.messagePrimary;
    const errDetail = err.detail || err.messageDetail;
    switch (code) {
      case "23503":
        index = errMessage.match(/violates foreign key constraint "(.+?)"/);
        index = index ? index[1] : void 0;
        table = errMessage.match(/on table "(.+?)"/);
        table = table ? table[1] : void 0;
        return new import_core.ForeignKeyConstraintError({
          message: errMessage,
          fields: null,
          index,
          table,
          cause: err
        });
      case "23505":
        if (errDetail && (match = errDetail.replaceAll('"', "").match(/Key \((.*?)\)=\((.*?)\)/))) {
          fields = (0, import_zipObject.default)(match[1].split(", "), match[2].split(", "));
          errors = [];
          message = "Validation error";
          (0, import_forOwn.default)(fields, (value, field) => {
            errors.push(
              new import_core.ValidationErrorItem(
                this.getUniqueConstraintErrorMessage(field),
                "unique violation",
                // ValidationErrorItem.Origins.DB,
                field,
                value,
                this.instance,
                "not_unique"
              )
            );
          });
          if (this.model) {
            for (const index2 of this.model.getIndexes()) {
              if (index2.unique && (0, import_isEqual.default)(index2.fields, Object.keys(fields)) && index2.msg) {
                message = index2.msg;
                break;
              }
            }
          }
          return new import_core.UniqueConstraintError({ message, errors, cause: err, fields });
        }
        return new import_core.UniqueConstraintError({
          message: errMessage,
          cause: err
        });
      case "23P01":
        match = errDetail.match(/Key \((.*?)\)=\((.*?)\)/);
        if (match) {
          fields = (0, import_zipObject.default)(match[1].split(", "), match[2].split(", "));
        }
        message = "Exclusion constraint error";
        return new import_core.ExclusionConstraintError({
          message,
          constraint: err.constraint,
          fields,
          table: err.table,
          cause: err
        });
      case "42704":
        if (err.sql && /(constraint|index)/gi.test(err.sql)) {
          message = "Unknown constraint error";
          index = errMessage.match(/(?:constraint|index) "(.+?)"/i);
          index = index ? index[1] : void 0;
          table = errMessage.match(/relation "(.+?)"/i);
          table = table ? table[1] : void 0;
          throw new import_core.UnknownConstraintError({
            message,
            constraint: index,
            fields,
            table,
            cause: err
          });
        }
      default:
        return new import_core.DatabaseError(err);
    }
  }
  getInsertIdField() {
    return "id";
  }
}
//# sourceMappingURL=query.js.map
