{
  "version": 3,
  "sources": ["../src/query-generator-typescript.internal.ts"],
  "sourcesContent": ["import type {\n  CreateDatabaseQueryOptions,\n  Expression,\n  ListDatabasesQueryOptions,\n  ListSchemasQueryOptions,\n  ListTablesQueryOptions,\n  RemoveIndexQueryOptions,\n  RenameTableQueryOptions,\n  ShowConstraintsQueryOptions,\n  TableOrModel,\n  TruncateTableQueryOptions,\n} from '@sequelize/core';\nimport { AbstractQueryGenerator } from '@sequelize/core';\nimport type { EscapeOptions } from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/query-generator-typescript.js';\nimport { CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS } from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/query-generator-typescript.js';\nimport { rejectInvalidOptions } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/check.js';\nimport { joinSQLFragments } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/join-sql-fragments.js';\nimport { generateIndexName } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/string.js';\nimport semver from 'semver';\nimport type { PostgresDialect } from './dialect.js';\nimport { PostgresQueryGeneratorInternal } from './query-generator.internal.js';\n\nconst CREATE_DATABASE_QUERY_SUPPORTED_OPTIONS = new Set<keyof CreateDatabaseQueryOptions>([\n  'collate',\n  'ctype',\n  'encoding',\n  'template',\n]);\n\n/**\n * Temporary class to ease the TypeScript migration\n */\nexport class PostgresQueryGeneratorTypeScript extends AbstractQueryGenerator {\n  readonly #internals: PostgresQueryGeneratorInternal;\n\n  constructor(\n    dialect: PostgresDialect,\n    internals: PostgresQueryGeneratorInternal = new PostgresQueryGeneratorInternal(dialect),\n  ) {\n    super(dialect, internals);\n\n    this.#internals = internals;\n  }\n\n  listDatabasesQuery(options?: ListDatabasesQueryOptions) {\n    let databasesToSkip = this.#internals.getTechnicalDatabaseNames();\n    if (options && Array.isArray(options?.skip)) {\n      databasesToSkip = [...databasesToSkip, ...options.skip];\n    }\n\n    return joinSQLFragments([\n      'SELECT datname AS \"name\" FROM pg_database',\n      `WHERE datistemplate = false AND datname NOT IN (${databasesToSkip.map(database => this.escape(database)).join(', ')})`,\n    ]);\n  }\n\n  createDatabaseQuery(database: string, options?: CreateDatabaseQueryOptions) {\n    if (options) {\n      rejectInvalidOptions(\n        'createDatabaseQuery',\n        this.dialect,\n        CREATE_DATABASE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_DATABASE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    return joinSQLFragments([\n      `CREATE DATABASE ${this.quoteIdentifier(database)}`,\n      options?.encoding ? `ENCODING = ${this.escape(options.encoding)}` : '',\n      options?.collate ? `LC_COLLATE = ${this.escape(options.collate)}` : '',\n      options?.ctype ? `LC_CTYPE = ${this.escape(options.ctype)}` : '',\n      options?.template ? `TEMPLATE = ${this.escape(options.template)}` : '',\n    ]);\n  }\n\n  listSchemasQuery(options?: ListSchemasQueryOptions) {\n    const schemasToSkip = ['public', ...this.#internals.getTechnicalSchemaNames()];\n\n    if (options && Array.isArray(options?.skip)) {\n      schemasToSkip.push(...options.skip);\n    }\n\n    return joinSQLFragments([\n      `SELECT schema_name AS \"schema\" FROM information_schema.schemata`,\n      `WHERE schema_name !~ E'^pg_' AND schema_name NOT IN (${schemasToSkip.map(schema => this.escape(schema)).join(', ')})`,\n    ]);\n  }\n\n  describeTableQuery(tableName: TableOrModel) {\n    const table = this.extractTableDetails(tableName);\n\n    return joinSQLFragments([\n      'SELECT',\n      'pk.constraint_type as \"Constraint\",',\n      'c.column_name as \"Field\",',\n      'c.column_default as \"Default\",',\n      'c.is_nullable as \"Null\",',\n      `(CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\",`,\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\",',\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\"',\n      'FROM information_schema.columns c',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name,',\n      'cu.column_name, tc.constraint_type',\n      'FROM information_schema.TABLE_CONSTRAINTS tc',\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name',\n      'and tc.constraint_name=cu.constraint_name',\n      `and tc.constraint_type='PRIMARY KEY') pk`,\n      'ON pk.table_schema=c.table_schema',\n      'AND pk.table_name=c.table_name',\n      'AND pk.column_name=c.column_name',\n      `WHERE c.table_name = ${this.escape(table.tableName)}`,\n      `AND c.table_schema = ${this.escape(table.schema)}`,\n    ]);\n  }\n\n  listTablesQuery(options?: ListTablesQueryOptions) {\n    return joinSQLFragments([\n      'SELECT table_name AS \"tableName\", table_schema AS \"schema\"',\n      `FROM information_schema.tables WHERE table_type = 'BASE TABLE' AND table_name != 'spatial_ref_sys'`,\n      options?.schema\n        ? `AND table_schema = ${this.escape(options.schema)}`\n        : `AND table_schema !~ E'^pg_' AND table_schema NOT IN (${this.#internals\n            .getTechnicalSchemaNames()\n            .map(schema => this.escape(schema))\n            .join(', ')})`,\n      'ORDER BY table_schema, table_name',\n    ]);\n  }\n\n  renameTableQuery(\n    beforeTableName: TableOrModel,\n    afterTableName: TableOrModel,\n    options?: RenameTableQueryOptions,\n  ): string {\n    const beforeTable = this.extractTableDetails(beforeTableName);\n    const afterTable = this.extractTableDetails(afterTableName);\n\n    if (beforeTable.schema !== afterTable.schema) {\n      if (!options?.changeSchema) {\n        throw new Error(\n          'To move a table between schemas, you must set `options.changeSchema` to true.',\n        );\n      }\n\n      if (beforeTable.tableName !== afterTable.tableName) {\n        throw new Error(\n          `Renaming a table and moving it to a different schema is not supported by ${this.dialect.name}.`,\n        );\n      }\n\n      return `ALTER TABLE ${this.quoteTable(beforeTableName)} SET SCHEMA ${this.quoteIdentifier(afterTable.schema)}`;\n    }\n\n    return `ALTER TABLE ${this.quoteTable(beforeTableName)} RENAME TO ${this.quoteIdentifier(afterTable.tableName)}`;\n  }\n\n  truncateTableQuery(tableName: TableOrModel, options?: TruncateTableQueryOptions) {\n    return joinSQLFragments([\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options?.restartIdentity ? 'RESTART IDENTITY' : '',\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  showConstraintsQuery(tableName: TableOrModel, options?: ShowConstraintsQueryOptions) {\n    const table = this.extractTableDetails(tableName);\n\n    // Postgres converts camelCased alias to lowercase unless quoted\n    return joinSQLFragments([\n      'SELECT c.constraint_catalog AS \"constraintCatalog\",',\n      'c.constraint_schema AS \"constraintSchema\",',\n      'c.constraint_name AS \"constraintName\",',\n      'c.constraint_type AS \"constraintType\",',\n      'c.table_catalog AS \"tableCatalog\",',\n      'c.table_schema AS \"tableSchema\",',\n      'c.table_name AS \"tableName\",',\n      'kcu.column_name AS \"columnNames\",',\n      'ccu.table_schema AS \"referencedTableSchema\",',\n      'ccu.table_name AS \"referencedTableName\",',\n      'ccu.column_name AS \"referencedColumnNames\",',\n      'r.delete_rule AS \"deleteAction\",',\n      'r.update_rule AS \"updateAction\",',\n      'ch.check_clause AS \"definition\",',\n      'c.is_deferrable AS \"isDeferrable\",',\n      'c.initially_deferred AS \"initiallyDeferred\"',\n      'FROM INFORMATION_SCHEMA.table_constraints c',\n      'LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name',\n      'LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name',\n      'LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name',\n      'LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name',\n      `WHERE c.table_name = ${this.escape(table.tableName)}`,\n      `AND c.table_schema = ${this.escape(table.schema)}`,\n      options?.columnName ? `AND kcu.column_name = ${this.escape(options.columnName)}` : '',\n      options?.constraintName\n        ? `AND c.constraint_name = ${this.escape(options.constraintName)}`\n        : '',\n      options?.constraintType\n        ? `AND c.constraint_type = ${this.escape(options.constraintType)}`\n        : '',\n      'ORDER BY c.constraint_name, kcu.ordinal_position',\n    ]);\n  }\n\n  showIndexesQuery(tableName: TableOrModel) {\n    const table = this.extractTableDetails(tableName);\n\n    // TODO [>=6]: refactor the query to use pg_indexes\n    return joinSQLFragments([\n      'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey[:ix.indnkeyatts-1] AS index_fields,',\n      'ix.indkey[ix.indnkeyatts:] AS include_fields, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names,',\n      'pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a , pg_namespace s',\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND',\n      `t.relkind = 'r' and t.relname = ${this.escape(table.tableName)}`,\n      `AND s.oid = t.relnamespace AND s.nspname = ${this.escape(table.schema)}`,\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey, ix.indnkeyatts ORDER BY i.relname;',\n    ]);\n  }\n\n  removeIndexQuery(\n    tableName: TableOrModel,\n    indexNameOrAttributes: string | string[],\n    options?: RemoveIndexQueryOptions,\n  ) {\n    if (options?.cascade && options?.concurrently) {\n      throw new Error(\n        `Cannot specify both concurrently and cascade options in removeIndexQuery for ${this.dialect.name} dialect`,\n      );\n    }\n\n    let indexName;\n    const table = this.extractTableDetails(tableName);\n    if (Array.isArray(indexNameOrAttributes)) {\n      indexName = generateIndexName(table, { fields: indexNameOrAttributes });\n    } else {\n      indexName = indexNameOrAttributes;\n    }\n\n    return joinSQLFragments([\n      'DROP INDEX',\n      options?.concurrently ? 'CONCURRENTLY' : '',\n      options?.ifExists ? 'IF EXISTS' : '',\n      `${this.quoteIdentifier(table.schema)}.${this.quoteIdentifier(indexName)}`,\n      options?.cascade ? 'CASCADE' : '',\n    ]);\n  }\n\n  jsonPathExtractionQuery(\n    sqlExpression: string,\n    path: ReadonlyArray<number | string>,\n    unquote: boolean,\n  ): string {\n    const operator = path.length === 1 ? (unquote ? '->>' : '->') : unquote ? '#>>' : '#>';\n\n    const pathSql =\n      path.length === 1\n        ? // when accessing an array index with ->, the index must be a number\n          // when accessing an object key with ->, the key must be a string\n          this.escape(path[0])\n        : // when accessing with #>, the path is always an array of strings\n          this.escape(path.map(value => String(value)));\n\n    return sqlExpression + operator + pathSql;\n  }\n\n  formatUnquoteJson(arg: Expression, options?: EscapeOptions) {\n    return `${this.escape(arg, options)}#>>ARRAY[]::TEXT[]`;\n  }\n\n  getUuidV1FunctionCall(): string {\n    return 'uuid_generate_v1()';\n  }\n\n  getUuidV4FunctionCall(): string {\n    const dialectVersion = this.sequelize.getDatabaseVersion();\n\n    if (semver.lt(dialectVersion, '13.0.0')) {\n      return 'uuid_generate_v4()';\n    }\n\n    // uuid_generate_v4 requires the uuid-ossp extension, which is not installed by default.\n    // This has broader support, as it is part of the core Postgres distribution, but is only available since Postgres 13.\n    return 'gen_random_uuid()';\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n}\n"],
  "mappings": "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",
  "names": ["semver"]
}
