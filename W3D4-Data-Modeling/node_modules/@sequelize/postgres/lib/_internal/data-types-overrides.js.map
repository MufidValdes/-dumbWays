{
  "version": 3,
  "sources": ["../../src/_internal/data-types-overrides.ts"],
  "sourcesContent": ["import type { AbstractDialect, Rangable } from '@sequelize/core';\nimport { attributeTypeToSql } from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/data-types-utils.js';\nimport type {\n  AbstractDataType,\n  AcceptableTypeOf,\n  AcceptedDate,\n  BindParamOptions,\n} from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/data-types.js';\nimport * as BaseTypes from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/data-types.js';\nimport { inspect, isBigInt, isNumber, isString } from '@sequelize/utils';\nimport identity from 'lodash/identity.js';\nimport assert from 'node:assert';\nimport wkx from 'wkx';\nimport { PostgresQueryGenerator } from '../query-generator';\nimport { stringifyHstore } from './hstore.js';\nimport { buildRangeParser, stringifyRange } from './range.js';\n\nfunction removeUnsupportedIntegerOptions(\n  dataType: BaseTypes.BaseIntegerDataType,\n  dialect: AbstractDialect,\n) {\n  if (dataType.options.length != null) {\n    // this option only makes sense for zerofill\n    dialect.warnDataTypeIssue(\n      `${dialect.name} does not support ${dataType.getDataTypeId()} with length specified. This options is ignored.`,\n    );\n\n    delete dataType.options.length;\n  }\n}\n\nexport class DATEONLY extends BaseTypes.DATEONLY {\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.DATEONLY>) {\n    if (value === Number.POSITIVE_INFINITY) {\n      return 'infinity';\n    }\n\n    if (value === Number.NEGATIVE_INFINITY) {\n      return '-infinity';\n    }\n\n    return super.toBindableValue(value);\n  }\n\n  sanitize(value: unknown): unknown {\n    if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase();\n      if (lower === 'infinity') {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (lower === '-infinity') {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n\n    return super.sanitize(value);\n  }\n}\n\nexport class DECIMAL extends BaseTypes.DECIMAL {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class TEXT extends BaseTypes.TEXT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.length) {\n      dialect.warnDataTypeIssue(\n        `${dialect.name} does not support TEXT with options. Plain TEXT will be used instead.`,\n      );\n\n      this.options.length = undefined;\n    }\n  }\n}\n\nexport class DATE extends BaseTypes.DATE {\n  toSql() {\n    if (this.options.precision != null) {\n      return `TIMESTAMP(${this.options.precision}) WITH TIME ZONE`;\n    }\n\n    return 'TIMESTAMP WITH TIME ZONE';\n  }\n\n  validate(value: any) {\n    if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {\n      // valid\n      return;\n    }\n\n    super.validate(value);\n  }\n\n  toBindableValue(value: AcceptedDate): string {\n    if (value === Number.POSITIVE_INFINITY) {\n      return 'infinity';\n    }\n\n    if (value === Number.NEGATIVE_INFINITY) {\n      return '-infinity';\n    }\n\n    return super.toBindableValue(value);\n  }\n\n  sanitize(value: unknown) {\n    if (value == null) {\n      return value;\n    }\n\n    if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {\n      return value;\n    }\n\n    if (value instanceof Date) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase();\n      if (lower === 'infinity') {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (lower === '-infinity') {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n\n    return super.sanitize(value);\n  }\n}\n\nexport class TINYINT extends BaseTypes.TINYINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^8-1 check when the unsigned option is true\n  // TODO: add >= -2^7 =< 2^7-1 check when the unsigned option is false\n\n  toSql(): string {\n    return 'SMALLINT';\n  }\n}\n\nexport class SMALLINT extends BaseTypes.SMALLINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^16-1 check when the unsigned option is true\n\n  toSql(): string {\n    if (this.options.unsigned) {\n      return 'INTEGER';\n    }\n\n    return 'SMALLINT';\n  }\n}\n\nexport class MEDIUMINT extends BaseTypes.MEDIUMINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^24-1 check when the unsigned option is true\n  // TODO: add >= -2^23 =< 2^23-1 check when the unsigned option is false\n\n  toSql(): string {\n    return 'INTEGER';\n  }\n}\n\nexport class INTEGER extends BaseTypes.INTEGER {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n\n  // TODO: add >= 0 =< 2^32-1 check when the unsigned option is true\n\n  toSql(): string {\n    if (this.options.unsigned) {\n      return 'BIGINT';\n    }\n\n    return 'INTEGER';\n  }\n}\n\nexport class BIGINT extends BaseTypes.BIGINT {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n    removeUnsupportedIntegerOptions(this, dialect);\n  }\n}\n\nexport class DOUBLE extends BaseTypes.DOUBLE {\n  // TODO: add check constraint >= 0 if unsigned is true\n}\n\nexport class FLOAT extends BaseTypes.FLOAT {\n  // TODO: add check constraint >= 0 if unsigned is true\n\n  protected getNumberSqlTypeName(): string {\n    // REAL is postgres' single precision float. FLOAT(p) is an alias for either REAL of DOUBLE PRECISION based on (p).\n    return 'REAL';\n  }\n}\n\nexport class BLOB extends BaseTypes.BLOB {\n  protected _checkOptionSupport(dialect: AbstractDialect) {\n    super._checkOptionSupport(dialect);\n\n    if (this.options.length) {\n      dialect.warnDataTypeIssue(\n        `${dialect.name} does not support BLOB (BYTEA) with options. Plain BYTEA will be used instead.`,\n      );\n      this.options.length = undefined;\n    }\n  }\n\n  toSql() {\n    return 'BYTEA';\n  }\n}\n\nexport class GEOMETRY extends BaseTypes.GEOMETRY {\n  toSql() {\n    let result = 'GEOMETRY';\n    if (this.options.type) {\n      result += `(${this.options.type.toUpperCase()}`;\n      if (this.options.srid) {\n        result += `,${this.options.srid}`;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  }\n\n  parse(value: string) {\n    const b = Buffer.from(value, 'hex');\n\n    return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n  }\n\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.GEOMETRY>): string {\n    return `ST_GeomFromGeoJSON(${this._getDialect().escapeString(JSON.stringify(value))})`;\n  }\n\n  getBindParamSql(value: AcceptableTypeOf<BaseTypes.GEOMETRY>, options: BindParamOptions) {\n    return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n  }\n}\n\nexport class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n  toSql() {\n    let result = 'GEOGRAPHY';\n    if (this.options.type) {\n      result += `(${this.options.type}`;\n      if (this.options.srid) {\n        result += `,${this.options.srid}`;\n      }\n\n      result += ')';\n    }\n\n    return result;\n  }\n\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.GEOGRAPHY>) {\n    return `ST_GeomFromGeoJSON(${this._getDialect().escapeString(JSON.stringify(value))})`;\n  }\n\n  getBindParamSql(value: AcceptableTypeOf<BaseTypes.GEOGRAPHY>, options: BindParamOptions) {\n    return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n  }\n}\n\nexport class HSTORE extends BaseTypes.HSTORE {\n  toBindableValue(value: AcceptableTypeOf<BaseTypes.HSTORE>): string {\n    if (value == null) {\n      return value;\n    }\n\n    return stringifyHstore(value);\n  }\n}\n\nconst defaultRangeParser = buildRangeParser(identity);\n\nexport class RANGE<\n  T extends BaseTypes.BaseNumberDataType | DATE | DATEONLY = INTEGER,\n> extends BaseTypes.RANGE<T> {\n  toBindableValue(values: Rangable<AcceptableTypeOf<T>>): string {\n    if (!Array.isArray(values)) {\n      throw new TypeError('Range values must be an array');\n    }\n\n    return stringifyRange(values, rangePart => {\n      let out = this.options.subtype.toBindableValue(rangePart);\n\n      if (isNumber(out) || isBigInt(out)) {\n        out = String(out);\n      }\n\n      if (!isString(out)) {\n        throw new Error(\n          'DataTypes.RANGE only accepts types that are represented by either strings, numbers or bigints.',\n        );\n      }\n\n      return out;\n    });\n  }\n\n  escape(values: Rangable<AcceptableTypeOf<T>>): string {\n    const value = this.toBindableValue(values);\n    const dialect = this._getDialect();\n\n    return `${dialect.escapeString(value)}::${this.toSql()}`;\n  }\n\n  getBindParamSql(values: Rangable<AcceptableTypeOf<T>>, options: BindParamOptions): string {\n    const value = this.toBindableValue(values);\n\n    return `${options.bindParam(value)}::${this.toSql()}`;\n  }\n\n  parseDatabaseValue(value: unknown): unknown {\n    // node-postgres workaround: The SQL Type-based parser is not called by node-postgres for values returned by Model.findOrCreate.\n    if (typeof value === 'string') {\n      value = defaultRangeParser(value);\n    }\n\n    if (!Array.isArray(value)) {\n      throw new Error(\n        `DataTypes.RANGE received a non-range value from the database: ${inspect(value)}`,\n      );\n    }\n\n    return value.map(part => {\n      return {\n        ...part,\n        value: this.options.subtype.parseDatabaseValue(part.value),\n      };\n    });\n  }\n\n  toSql() {\n    const subTypeClass = this.options.subtype.constructor as typeof BaseTypes.AbstractDataType;\n\n    return RANGE.typeMap[subTypeClass.getDataTypeId().toLowerCase()];\n  }\n\n  static typeMap: Record<string, string> = {\n    integer: 'int4range',\n    decimal: 'numrange',\n    date: 'tstzrange',\n    dateonly: 'daterange',\n    bigint: 'int8range',\n  };\n}\n\nexport class ARRAY<T extends BaseTypes.AbstractDataType<any>> extends BaseTypes.ARRAY<T> {\n  escape(values: Array<AcceptableTypeOf<T>>) {\n    const type = this.options.type;\n\n    const mappedValues = isString(type) ? values : values.map(value => type.escape(value));\n\n    // Types that don't need to specify their cast\n    const unambiguousType = type instanceof BaseTypes.TEXT || type instanceof BaseTypes.INTEGER;\n\n    const cast =\n      mappedValues.length === 0 || !unambiguousType ? `::${attributeTypeToSql(type)}[]` : '';\n\n    return `ARRAY[${mappedValues.join(',')}]${cast}`;\n  }\n\n  getBindParamSql(values: Array<AcceptableTypeOf<T>>, options: BindParamOptions) {\n    if (isString(this.options.type)) {\n      return options.bindParam(values);\n    }\n\n    const subType: AbstractDataType<any> = this.options.type;\n\n    return options.bindParam(\n      values.map((value: any) => {\n        return subType.toBindableValue(value);\n      }),\n    );\n  }\n}\n\nexport class ENUM<Members extends string> extends BaseTypes.ENUM<Members> {\n  override toSql(): string {\n    const context = this.usageContext;\n    if (context == null) {\n      throw new Error(\n        'Could not determine the name of this enum because it is not attached to an attribute or a column.',\n      );\n    }\n\n    let tableName;\n    let columnName;\n    if ('model' in context) {\n      tableName = context.model.table;\n\n      const attribute = context.model.getAttributes()[context.attributeName];\n      columnName = attribute.field ?? context.attributeName;\n    } else {\n      tableName = context.tableName;\n      columnName = context.columnName;\n    }\n\n    const queryGenerator = context.sequelize.dialect.queryGenerator;\n\n    assert(\n      queryGenerator instanceof PostgresQueryGenerator,\n      'expected queryGenerator to be PostgresQueryGenerator',\n    );\n\n    return queryGenerator.pgEnumName(tableName, columnName);\n  }\n}\n"],
  "mappings": "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",
  "names": ["wkx", "identity", "assert"]
}
