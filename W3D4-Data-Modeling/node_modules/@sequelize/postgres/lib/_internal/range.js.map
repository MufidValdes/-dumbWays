{
  "version": 3,
  "sources": ["../../src/_internal/range.ts"],
  "sourcesContent": ["import type { InputRangePart, Rangable, Range, RangePart } from '@sequelize/core';\nimport isPlainObject from 'lodash/isPlainObject';\nimport NodeUtil from 'node:util';\n\nfunction stringifyRangeBound<T extends {}>(\n  bound: T | number | null,\n  stringifyBoundary: (val: T) => string,\n): string {\n  if (bound === null) {\n    return '';\n  }\n\n  if (bound === Number.POSITIVE_INFINITY || bound === Number.NEGATIVE_INFINITY) {\n    return bound.toString().toLowerCase();\n  }\n\n  return stringifyBoundary(bound as T);\n}\n\ntype ParseValue<T> = (input: string) => T;\n\nfunction parseRangeBound<T>(bound: string, parseType: ParseValue<T>): T | number | null {\n  if (!bound) {\n    return null;\n  }\n\n  if (bound === 'infinity') {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  if (bound === '-infinity') {\n    return Number.NEGATIVE_INFINITY;\n  }\n\n  if (bound.startsWith('\"')) {\n    bound = bound.slice(1);\n  }\n\n  if (bound.endsWith('\"')) {\n    bound = bound.slice(0, -1);\n  }\n\n  return parseType(bound);\n}\n\nexport function stringifyRange<T extends {}>(\n  range: Rangable<T>,\n  stringifyBoundary: (val: T) => string,\n): string {\n  if (range.length === 0) {\n    return 'empty';\n  }\n\n  if (range.length !== 2) {\n    throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n  }\n\n  const inclusivity = [true, false];\n  const bounds = range.map((rangePart, index) => {\n    if (isInputRangePart<T>(rangePart)) {\n      if (typeof rangePart.inclusive === 'boolean') {\n        inclusivity[index] = rangePart.inclusive;\n      }\n\n      rangePart = rangePart.value;\n    }\n\n    return stringifyRangeBound(rangePart, stringifyBoundary);\n  });\n\n  return `${(inclusivity[0] ? '[' : '(') + bounds[0]},${bounds[1]}${inclusivity[1] ? ']' : ')'}`;\n}\n\nexport function parseRange<T>(value: string, parser: ParseValue<T>): Range<T> {\n  if (typeof value !== 'string') {\n    throw new TypeError(`Sequelize could not parse range \"${value}\" as its format is incompatible`);\n  }\n\n  if (value === 'empty') {\n    return [];\n  }\n\n  const result = value.slice(1, -1).split(',', 2);\n\n  if (result.length !== 2) {\n    throw new TypeError(`Sequelize could not parse range \"${value}\" as its format is incompatible`);\n  }\n\n  return result.map((item, index) => {\n    const part: RangePart<T | number | null> = {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value.startsWith('[') : value.endsWith(']'),\n    };\n\n    return part;\n  }) as Range<T>;\n}\n\nexport function isInputRangePart<T>(val: unknown): val is InputRangePart<T> {\n  return isPlainObject(val) && Object.hasOwn(val as object, 'value');\n}\n\nexport function buildRangeParser(\n  subTypeParser: (value: unknown) => unknown,\n): (value: unknown) => unknown {\n  return (value: unknown) => {\n    if (typeof value !== 'string') {\n      throw new TypeError(\n        NodeUtil.format(\n          `Sequelize could not parse range \"%O\" as its format is incompatible`,\n          value,\n        ),\n      );\n    }\n\n    return parseRange(value, subTypeParser);\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,2BAA0B;AAC1B,uBAAqB;AAErB,SAAS,oBACP,OACA,mBACQ;AACR,MAAI,UAAU,MAAM;AAClB,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,OAAO,qBAAqB,UAAU,OAAO,mBAAmB;AAC5E,WAAO,MAAM,SAAS,EAAE,YAAY;AAAA,EACtC;AAEA,SAAO,kBAAkB,KAAU;AACrC;AAIA,SAAS,gBAAmB,OAAe,WAA6C;AACtF,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,YAAY;AACxB,WAAO,OAAO;AAAA,EAChB;AAEA,MAAI,UAAU,aAAa;AACzB,WAAO,OAAO;AAAA,EAChB;AAEA,MAAI,MAAM,WAAW,GAAG,GAAG;AACzB,YAAQ,MAAM,MAAM,CAAC;AAAA,EACvB;AAEA,MAAI,MAAM,SAAS,GAAG,GAAG;AACvB,YAAQ,MAAM,MAAM,GAAG,EAAE;AAAA,EAC3B;AAEA,SAAO,UAAU,KAAK;AACxB;AAEO,SAAS,eACd,OACA,mBACQ;AACR,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,WAAW,GAAG;AACtB,UAAM,IAAI,MAAM,oEAAoE;AAAA,EACtF;AAEA,QAAM,cAAc,CAAC,MAAM,KAAK;AAChC,QAAM,SAAS,MAAM,IAAI,CAAC,WAAW,UAAU;AAC7C,QAAI,iBAAoB,SAAS,GAAG;AAClC,UAAI,OAAO,UAAU,cAAc,WAAW;AAC5C,oBAAY,KAAK,IAAI,UAAU;AAAA,MACjC;AAEA,kBAAY,UAAU;AAAA,IACxB;AAEA,WAAO,oBAAoB,WAAW,iBAAiB;AAAA,EACzD,CAAC;AAED,SAAO,IAAI,YAAY,CAAC,IAAI,MAAM,OAAO,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,YAAY,CAAC,IAAI,MAAM;AAC3F;AAEO,SAAS,WAAc,OAAe,QAAiC;AAC5E,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,IAAI,UAAU,oCAAoC,sCAAsC;AAAA,EAChG;AAEA,MAAI,UAAU,SAAS;AACrB,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,SAAS,MAAM,MAAM,GAAG,EAAE,EAAE,MAAM,KAAK,CAAC;AAE9C,MAAI,OAAO,WAAW,GAAG;AACvB,UAAM,IAAI,UAAU,oCAAoC,sCAAsC;AAAA,EAChG;AAEA,SAAO,OAAO,IAAI,CAAC,MAAM,UAAU;AACjC,UAAM,OAAqC;AAAA,MACzC,OAAO,gBAAgB,MAAM,MAAM;AAAA,MACnC,WAAW,UAAU,IAAI,MAAM,WAAW,GAAG,IAAI,MAAM,SAAS,GAAG;AAAA,IACrE;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,SAAS,iBAAoB,KAAwC;AAC1E,aAAO,qBAAAA,SAAc,GAAG,KAAK,OAAO,OAAO,KAAe,OAAO;AACnE;AAEO,SAAS,iBACd,eAC6B;AAC7B,SAAO,CAAC,UAAmB;AACzB,QAAI,OAAO,UAAU,UAAU;AAC7B,YAAM,IAAI;AAAA,QACR,iBAAAC,QAAS;AAAA,UACP;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,WAAW,OAAO,aAAa;AAAA,EACxC;AACF;",
  "names": ["isPlainObject", "NodeUtil"]
}
