"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var connection_manager_exports = {};
__export(connection_manager_exports, {
  PostgresConnectionManager: () => PostgresConnectionManager
});
module.exports = __toCommonJS(connection_manager_exports);
var import_core = require("@sequelize/core");
var import_dayjs = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/dayjs.js");
var import_logger = require("@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js");
var Pg = __toESM(require("pg"));
var import_postgres_array = require("postgres-array");
var import_semver = __toESM(require("semver"));
const debug = import_logger.logger.debugContext("connection:pg");
class PostgresConnectionManager extends import_core.AbstractConnectionManager {
  #lib;
  #oidMap = /* @__PURE__ */ new Map();
  #oidParserCache = /* @__PURE__ */ new Map();
  constructor(dialect) {
    super(dialect);
    const pgModule = dialect.options.pgModule ?? Pg;
    if (dialect.options.native && dialect.options.pgModule) {
      throw new Error(
        'You cannot specify both the "pgModule" option and the "native" option at the same time, as the "native" option is only used to use "pg-native" as the "pgModule" instead of "pg"'
      );
    }
    if (dialect.options.native && !pgModule.native) {
      throw new Error(
        'The "native" option was specified, but the "pg-native" module is not installed. You must install it to use the native bindings.'
      );
    }
    this.#lib = dialect.options.native ? pgModule.native : pgModule;
  }
  async connect(config) {
    const connectionConfig = {
      port: 5432,
      ...config,
      types: {
        getTypeParser: (oid, format) => this.getTypeParser(oid, format)
      }
    };
    const connection = new this.#lib.Client(connectionConfig);
    await new Promise((resolve, reject) => {
      let responded = false;
      const parameterHandler = (message) => {
        switch (message.parameterName) {
          case "server_version": {
            const version = import_semver.default.coerce(message.parameterValue)?.version;
            this.sequelize.setDatabaseVersion(
              version && import_semver.default.valid(version) ? version : this.dialect.minimumDatabaseVersion
            );
            break;
          }
          case "standard_conforming_strings": {
            connection.standard_conforming_strings = message.parameterValue === "on";
            break;
          }
          default:
        }
      };
      const endHandler = () => {
        debug("connection timeout");
        if (!responded) {
          reject(new import_core.ConnectionTimedOutError(new Error("Connection timed out")));
        }
      };
      connection.once("end", endHandler);
      if (!this.dialect.options.native) {
        connection.connection.on("parameterStatus", parameterHandler);
      }
      connection.connect((err) => {
        responded = true;
        if (!this.dialect.options.native) {
          connection.connection.removeListener("parameterStatus", parameterHandler);
        }
        if (err) {
          if (err.code) {
            switch (err.code) {
              case "ECONNREFUSED":
                reject(new import_core.ConnectionRefusedError(err));
                break;
              case "ENOTFOUND":
                reject(new import_core.HostNotFoundError(err));
                break;
              case "EHOSTUNREACH":
                reject(new import_core.HostNotReachableError(err));
                break;
              case "EINVAL":
                reject(new import_core.InvalidConnectionError(err));
                break;
              default:
                reject(new import_core.ConnectionError(err));
                break;
            }
          } else {
            reject(new import_core.ConnectionError(err));
          }
        } else {
          debug("connection acquired");
          connection.removeListener("end", endHandler);
          resolve(connection);
        }
      });
    });
    connection.on("error", (error) => {
      connection._invalid = true;
      debug(`connection error ${error.code || error.message}`);
      void this.sequelize.pool.destroy(connection);
    });
    let query = "";
    if (this.dialect.options.standardConformingStrings !== false && connection.standard_conforming_strings) {
      query += "SET standard_conforming_strings=on;";
    }
    const clientMinMessages = this.dialect.options.clientMinMessages ?? "warning";
    if (clientMinMessages) {
      query += `SET client_min_messages TO ${clientMinMessages};`;
    }
    if (!this.sequelize.options.keepDefaultTimezone) {
      if (this.sequelize.options.timezone && (0, import_dayjs.isValidTimeZone)(this.sequelize.options.timezone)) {
        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;
      } else {
        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;
      }
    }
    if (query) {
      await connection.query(query);
    }
    await this.#refreshOidMap(connection);
    return connection;
  }
  async disconnect(connection) {
    if (connection._ending) {
      debug("connection tried to disconnect but was already at ENDING state");
      return;
    }
    await connection.end();
  }
  validate(connection) {
    return !connection._invalid && !connection._ending;
  }
  async #refreshOidMap(connection) {
    const sql = `
      WITH ranges AS (SELECT pg_range.rngtypid,
                             pg_type.typname  AS rngtypname,
                             pg_type.typarray AS rngtyparray,
                             pg_range.rngsubtype
                      FROM pg_range
                             LEFT OUTER JOIN pg_type
                                             ON pg_type.oid = pg_range.rngtypid)
      SELECT pg_type.typname,
             pg_type.typtype,
             pg_type.oid,
             pg_type.typarray,
             ranges.rngtypname,
             ranges.rngtypid,
             ranges.rngtyparray
      FROM pg_type
             LEFT OUTER JOIN ranges
                             ON pg_type.oid = ranges.rngsubtype
      WHERE (pg_type.typtype IN ('b', 'e'));
    `;
    let results;
    if (connection instanceof import_core.Sequelize) {
      results = (await connection.query(sql)).pop();
    } else {
      results = await connection.query(sql);
    }
    if (Array.isArray(results) && results[0].command === "SET") {
      results = results.pop();
    }
    const oidMap = this.#oidMap;
    oidMap.clear();
    for (const row of results.rows) {
      if (!oidMap.has(row.oid)) {
        oidMap.set(row.oid, {
          oid: row.oid,
          typeName: row.typname,
          type: "base"
        });
      }
      if (row.typarray) {
        oidMap.set(row.typarray, {
          oid: row.typarray,
          typeName: row.typname,
          type: "array",
          baseOid: row.oid
        });
      }
      if (row.rngtypid) {
        oidMap.set(row.rngtypid, {
          oid: row.rngtypid,
          typeName: row.rngtypname,
          type: "range",
          baseOid: row.oid
        });
      }
      if (row.rngtyparray) {
        oidMap.set(row.rngtyparray, {
          oid: row.rngtyparray,
          typeName: row.rngtypname,
          type: "range-array",
          baseOid: row.oid,
          rangeOid: row.rngtypid
        });
      }
    }
  }
  #buildArrayParser(subTypeParser) {
    return (source) => {
      return (0, import_postgres_array.parse)(source, subTypeParser);
    };
  }
  getTypeParser(oid, format) {
    const cachedParser = this.#oidParserCache.get(oid);
    if (cachedParser) {
      return cachedParser;
    }
    const customParser = this.#getCustomTypeParser(oid, format);
    if (customParser) {
      this.#oidParserCache.set(oid, customParser);
      return customParser;
    }
    switch (format) {
      case "text":
        return this.#lib.types.getTypeParser(oid, format);
      case "binary":
        return this.#lib.types.getTypeParser(oid, format);
      default:
        return this.#lib.types.getTypeParser(oid);
    }
  }
  #getCustomTypeParser(oid, format) {
    const typeData = this.#oidMap.get(oid);
    if (!typeData) {
      return null;
    }
    if (typeData.type === "range-array") {
      return this.#buildArrayParser(this.getTypeParser(typeData.rangeOid, format));
    }
    if (typeData.type === "array") {
      return this.#buildArrayParser(this.getTypeParser(typeData.baseOid, format));
    }
    const parser = this.dialect.getParserForDatabaseDataType(typeData.typeName);
    return parser ?? null;
  }
  /**
   * Refreshes the local registry of Custom Types (e.g. enum) OIDs
   */
  async refreshDynamicOids() {
    await this.#refreshOidMap(this.sequelize);
  }
}
//# sourceMappingURL=connection-manager.js.map
