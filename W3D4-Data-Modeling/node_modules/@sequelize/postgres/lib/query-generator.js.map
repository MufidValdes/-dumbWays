{
  "version": 3,
  "sources": ["../src/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nimport { DataTypes } from '@sequelize/core';\nimport { CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS } from '@sequelize/core/_non-semver-use-at-your-own-risk_/abstract-dialect/query-generator.js';\nimport { rejectInvalidOptions } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/check.js';\nimport { quoteIdentifier } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/dialect.js';\nimport { defaultValueSchemable } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/query-builder-utils.js';\nimport { generateIndexName } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/string.js';\nimport each from 'lodash/each';\nimport isEmpty from 'lodash/isEmpty';\nimport isPlainObject from 'lodash/isPlainObject';\nimport map from 'lodash/map';\nimport reduce from 'lodash/reduce';\nimport { ENUM } from './_internal/data-types-overrides.js';\nimport { PostgresQueryGeneratorTypeScript } from './query-generator-typescript.internal.js';\nimport { PostgresQueryGeneratorInternal } from './query-generator.internal.js';\n\n/**\n * list of reserved words in PostgreSQL 10\n * source: https://www.postgresql.org/docs/10/static/sql-keywords-appendix.html\n *\n * @private\n */\nconst POSTGRES_RESERVED_WORDS =\n  'all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with'.split(\n    ',',\n  );\n\nconst CREATE_TABLE_QUERY_SUPPORTED_OPTIONS = new Set(['comment', 'uniqueKeys']);\n\nexport class PostgresQueryGenerator extends PostgresQueryGeneratorTypeScript {\n  #internals;\n\n  constructor(dialect, internals = new PostgresQueryGeneratorInternal(dialect)) {\n    super(dialect, internals);\n\n    this.#internals = internals;\n  }\n\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    if (options) {\n      rejectInvalidOptions(\n        'createTableQuery',\n        this.dialect,\n        CREATE_TABLE_QUERY_SUPPORTABLE_OPTIONS,\n        CREATE_TABLE_QUERY_SUPPORTED_OPTIONS,\n        options,\n      );\n    }\n\n    options = { ...options };\n\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].slice(Math.max(0, i + 8)));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].slice(0, Math.max(0, i));\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      each(options.uniqueKeys, (index, indexName) => {\n        if (typeof indexName !== 'string') {\n          indexName = generateIndexName(tableName, index);\n        }\n\n        attributesClause += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${index.fields\n          .map(field => this.quoteIdentifier(field))\n          .join(', ')})`;\n      });\n    }\n\n    const pks = reduce(\n      attributes,\n      (acc, attribute, key) => {\n        if (attribute.includes('PRIMARY KEY')) {\n          acc.push(this.quoteIdentifier(key));\n        }\n\n        return acc;\n      },\n      [],\n    ).join(', ');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  addColumnQuery(table, key, attribute, options) {\n    options ||= {};\n\n    const dbDataType = this.attributeToSQL(attribute, { context: 'addColumn', table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(table);\n    const ifNotExists = options.ifNotExists ? ' IF NOT EXISTS' : '';\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${ifNotExists} ${quotedKey} ${definition};`;\n\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (\n      dataType instanceof DataTypes.ARRAY &&\n      dataType.options.type instanceof DataTypes.ENUM\n    ) {\n      query = this.pgEnum(table, key, dataType.options.type) + query;\n    }\n\n    return query;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(\n          `${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`,\n        );\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(\n          /^ENUM\\(.+\\)/,\n          this.pgEnumName(tableName, attributeName, { schema: false }),\n        );\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (/UNIQUE;*$/.test(definition)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace(\n          'ALTER COLUMN',\n          '',\n        );\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(\n          `ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`,\n        ).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(\n        `${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`,\n      );\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName ||= 'testfunc';\n    language ||= 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters ||= '';\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!isPlainObject(attribute)) {\n      attribute = {\n        type: attribute,\n      };\n    }\n\n    let type;\n    if (\n      attribute.type instanceof DataTypes.ENUM ||\n      (attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM)\n    ) {\n      const enumType = attribute.type.type || attribute.type;\n      const values = enumType.options.values;\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (attribute.allowNull === false) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (defaultValueSchemable(attribute.defaultValue, this.dialect)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, { type: attribute.type })}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if (\n        (!attribute.references.table || typeof attribute.references.table === 'string') &&\n        options.table &&\n        options.table.schema\n      ) {\n        schema = options.table.schema;\n      }\n\n      const referencesTable = this.extractTableDetails(attribute.references.table, { schema });\n\n      let referencesKey;\n\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier('id');\n        }\n\n        sql += ` REFERENCES ${this.quoteTable(referencesTable)} (${referencesKey})`;\n\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n\n        if (attribute.references.deferrable) {\n          sql += ` ${this.#internals.getDeferrableConstraintSnippet(attribute.references.deferrable)}`;\n        }\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && ['addColumn', 'changeColumn'].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, { key, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger(\n    tableName,\n    triggerName,\n    eventType,\n    fireOnSpec,\n    functionName,\n    functionParams,\n    optionsArray,\n  ) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) {\n      throw new Error(\n        'createFunction missing some parameters. Did you pass functionName, returnType, language and body?',\n      );\n    }\n\n    const paramList = this._expandFunctionParamList(params);\n    const variableList =\n      options && options.variables ? this._expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) {\n      throw new Error('requires functionName');\n    }\n\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this._expandFunctionParamList(params);\n\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  _expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error(\n        '_expandFunctionParamList: function parameters array required, including an empty one for no arguments',\n      );\n    }\n\n    const paramList = [];\n    for (const curParam of params) {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) {\n        paramList.push(joined);\n      }\n    }\n\n    return paramList.join(', ');\n  }\n\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new TypeError('_expandFunctionVariableList: function variables must be an array');\n    }\n\n    const variableDefinitions = [];\n    for (const variable of variables) {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    }\n\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || isEmpty(options) ? '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      after: 'AFTER',\n      before: 'BEFORE',\n      instead_of: 'INSTEAD OF',\n      after_constraint: 'AFTER',\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        insert: 'INSERT',\n        update: 'UPDATE',\n        delete: 'DELETE',\n        truncate: 'TRUNCATE',\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === 'UPDATE' && Array.isArray(fireValue) && fireValue.length > 0) {\n        eventSpec += ` OF ${fireValue.join(', ')}`;\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, columnName, options = {}) {\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    const enumName = `enum_${tableDetails.tableName}_${columnName}`;\n    if (options.noEscape) {\n      return enumName;\n    }\n\n    const escapedEnumName = this.quoteIdentifier(enumName);\n\n    if (options.schema !== false && tableDetails.schema) {\n      return this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + escapedEnumName;\n    }\n\n    return escapedEnumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails =\n      tableName != null\n        ? this.extractTableDetails(tableName, options)\n        : { schema: this.options.schema || this.dialect.getDefaultSchema() };\n\n    if (tableDetails.tableName && attrName) {\n      // pgEnumName escapes as an identifier, we want to escape it as a string\n      enumName = ` AND t.typname=${this.escape(this.pgEnumName(tableDetails.tableName, attrName, { noEscape: true }))}`;\n    }\n\n    return (\n      'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +\n      'JOIN pg_enum e ON t.oid = e.enumtypid ' +\n      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +\n      `WHERE n.nspname = ${this.escape(tableDetails.schema)}${enumName} GROUP BY 1`\n    );\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType instanceof ENUM && dataType.options.values) {\n      values = `ENUM(${dataType.options.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `DO ${this.escape(`BEGIN CREATE TYPE ${enumName} AS ${values}; EXCEPTION WHEN duplicate_object THEN null; END`)};`;\n    if (Boolean(options) && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE IF NOT EXISTS `;\n\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName ||= this.pgEnumName(tableName, attr);\n\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    if (Array.isArray(text)) {\n      return text;\n    }\n\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/gi);\n\n    if (matches.length === 0) {\n      return [];\n    }\n\n    matches = matches.map(m =>\n      m\n        .replace(/\",$/, '')\n        .replace(/,$/, '')\n        .replaceAll(/(^\"|\"$)/g, ''),\n    );\n\n    return matches.slice(0, -1);\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    // TODO [>7]: remove \"quoteIdentifiers: false\" option\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n\n    if (\n      optForceQuote === true ||\n      // TODO [>7]: drop this.options.quoteIdentifiers. Always quote identifiers based on these rules\n      optQuoteIdentifiers !== false ||\n      identifier.includes('.') ||\n      identifier.includes('->') ||\n      POSTGRES_RESERVED_WORDS.includes(identifier.toLowerCase())\n    ) {\n      // In Postgres if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return quoteIdentifier(identifier, this.dialect.TICK_CHAR_LEFT, this.dialect.TICK_CHAR_RIGHT);\n    }\n\n    return identifier;\n  }\n}\n"],
  "mappings": "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",
  "names": ["each", "reduce", "isPlainObject", "isEmpty", "map"]
}
